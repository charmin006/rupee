"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uuidv7";
exports.ids = ["vendor-chunks/uuidv7"];
exports.modules = {

/***/ "(ssr)/./node_modules/uuidv7/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/uuidv7/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UUID: () => (/* binding */ UUID),\n/* harmony export */   V7Generator: () => (/* binding */ V7Generator),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   uuidv4obj: () => (/* binding */ uuidv4obj),\n/* harmony export */   uuidv7: () => (/* binding */ uuidv7),\n/* harmony export */   uuidv7obj: () => (/* binding */ uuidv7obj)\n/* harmony export */ });\n/**\n * uuidv7: A JavaScript implementation of UUID version 7\n *\n * Copyright 2021-2024 LiosK\n *\n * @license Apache-2.0\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nclass UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */\nclass V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nconst uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nconst uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nconst uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXVpZHY3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEdBQUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksR0FBRyxHQUFHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxHQUFHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjLEtBQUssZ0JBQWdCO0FBQ2hFLGdCQUFnQixnQkFBZ0Isd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsUUFBUSwyQkFBMkI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ydXBlZS1maW5hbmNlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvdXVpZHY3L2Rpc3QvaW5kZXguanM/ZDRjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHV1aWR2NzogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFVVSUQgdmVyc2lvbiA3XG4gKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyNCBMaW9zS1xuICpcbiAqIEBsaWNlbnNlIEFwYWNoZS0yLjBcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5jb25zdCBESUdJVFMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbi8qKiBSZXByZXNlbnRzIGEgVVVJRCBhcyBhIDE2LWJ5dGUgYnl0ZSBhcnJheS4gKi9cbmV4cG9ydCBjbGFzcyBVVUlEIHtcbiAgICAvKiogQHBhcmFtIGJ5dGVzIC0gVGhlIDE2LWJ5dGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbi4gKi9cbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGZyb20gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLCBhIDE2LWJ5dGUgYnl0ZSBhcnJheVxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGJpbmFyeSBVVUlEIHJlcHJlc2VudGF0aW9uIGluIHRoZSBiaWctZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIE5PVCBzaGFsbG93LWNvcHkgdGhlIGFyZ3VtZW50LCBhbmQgdGh1cyB0aGUgY3JlYXRlZCBvYmplY3RcbiAgICAgKiBob2xkcyB0aGUgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgVHlwZUVycm9yIGlmIHRoZSBsZW5ndGggb2YgdGhlIGFyZ3VtZW50IGlzIG5vdCAxNi5cbiAgICAgKi9cbiAgICBzdGF0aWMgb2ZJbm5lcihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCAxMjgtYml0IGxlbmd0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgYnl0ZSBhcnJheSBmcm9tIFVVSUR2NyBmaWVsZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdW5peFRzTXMgLSBBIDQ4LWJpdCBgdW5peF90c19tc2AgZmllbGQgdmFsdWUuXG4gICAgICogQHBhcmFtIHJhbmRBIC0gQSAxMi1iaXQgYHJhbmRfYWAgZmllbGQgdmFsdWUuXG4gICAgICogQHBhcmFtIHJhbmRCSGkgLSBUaGUgaGlnaGVyIDMwIGJpdHMgb2YgNjItYml0IGByYW5kX2JgIGZpZWxkIHZhbHVlLlxuICAgICAqIEBwYXJhbSByYW5kQkxvIC0gVGhlIGxvd2VyIDMyIGJpdHMgb2YgNjItYml0IGByYW5kX2JgIGZpZWxkIHZhbHVlLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBhbnkgZmllbGQgdmFsdWUgaXMgb3V0IG9mIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21GaWVsZHNWNyh1bml4VHNNcywgcmFuZEEsIHJhbmRCSGksIHJhbmRCTG8pIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHVuaXhUc01zKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIocmFuZEEpIHx8XG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihyYW5kQkhpKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIocmFuZEJMbykgfHxcbiAgICAgICAgICAgIHVuaXhUc01zIDwgMCB8fFxuICAgICAgICAgICAgcmFuZEEgPCAwIHx8XG4gICAgICAgICAgICByYW5kQkhpIDwgMCB8fFxuICAgICAgICAgICAgcmFuZEJMbyA8IDAgfHxcbiAgICAgICAgICAgIHVuaXhUc01zID4gMjgxNDc0OTc2NzEwNjU1IHx8XG4gICAgICAgICAgICByYW5kQSA+IDB4ZmZmIHx8XG4gICAgICAgICAgICByYW5kQkhpID4gMTA3Mzc0MTgyMyB8fFxuICAgICAgICAgICAgcmFuZEJMbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW52YWxpZCBmaWVsZCB2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgYnl0ZXNbMF0gPSB1bml4VHNNcyAvIDIgKiogNDA7XG4gICAgICAgIGJ5dGVzWzFdID0gdW5peFRzTXMgLyAyICoqIDMyO1xuICAgICAgICBieXRlc1syXSA9IHVuaXhUc01zIC8gMiAqKiAyNDtcbiAgICAgICAgYnl0ZXNbM10gPSB1bml4VHNNcyAvIDIgKiogMTY7XG4gICAgICAgIGJ5dGVzWzRdID0gdW5peFRzTXMgLyAyICoqIDg7XG4gICAgICAgIGJ5dGVzWzVdID0gdW5peFRzTXM7XG4gICAgICAgIGJ5dGVzWzZdID0gMHg3MCB8IChyYW5kQSA+Pj4gOCk7XG4gICAgICAgIGJ5dGVzWzddID0gcmFuZEE7XG4gICAgICAgIGJ5dGVzWzhdID0gMHg4MCB8IChyYW5kQkhpID4+PiAyNCk7XG4gICAgICAgIGJ5dGVzWzldID0gcmFuZEJIaSA+Pj4gMTY7XG4gICAgICAgIGJ5dGVzWzEwXSA9IHJhbmRCSGkgPj4+IDg7XG4gICAgICAgIGJ5dGVzWzExXSA9IHJhbmRCSGk7XG4gICAgICAgIGJ5dGVzWzEyXSA9IHJhbmRCTG8gPj4+IDI0O1xuICAgICAgICBieXRlc1sxM10gPSByYW5kQkxvID4+PiAxNjtcbiAgICAgICAgYnl0ZXNbMTRdID0gcmFuZEJMbyA+Pj4gODtcbiAgICAgICAgYnl0ZXNbMTVdID0gcmFuZEJMbztcbiAgICAgICAgcmV0dXJuIG5ldyBVVUlEKGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgYnl0ZSBhcnJheSBmcm9tIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWNjZXB0cyB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAgICpcbiAgICAgKiAtIDMyLWRpZ2l0IGhleGFkZWNpbWFsIGZvcm1hdCB3aXRob3V0IGh5cGhlbnM6IGAwMTg5ZGNkNTUzMTE3ZDQwOGRiMDk0OTZhMmVlZjM3YmBcbiAgICAgKiAtIDgtNC00LTQtMTIgaHlwaGVuYXRlZCBmb3JtYXQ6IGAwMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2JgXG4gICAgICogLSBIeXBoZW5hdGVkIGZvcm1hdCB3aXRoIHN1cnJvdW5kaW5nIGJyYWNlczogYHswMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2J9YFxuICAgICAqIC0gUkZDIDk1NjIgVVJOIGZvcm1hdDogYHVybjp1dWlkOjAxODlkY2Q1LTUzMTEtN2Q0MC04ZGIwLTk0OTZhMmVlZjM3YmBcbiAgICAgKlxuICAgICAqIExlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VzIHJlcHJlc2VudHMgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFN5bnRheEVycm9yIGlmIHRoZSBhcmd1bWVudCBjb3VsZCBub3QgcGFyc2UgYXMgYSB2YWxpZCBVVUlEIHN0cmluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2UodXVpZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBoZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAodXVpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgaGV4ID0gKF9hID0gL15bMC05YS1mXXszMn0kL2kuZXhlYyh1dWlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgICBoZXggPVxuICAgICAgICAgICAgICAgICAgICAoX2IgPSAvXihbMC05YS1mXXs4fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezEyfSkkL2lcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjKHV1aWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpY2UoMSwgNikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgaGV4ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gL15cXHsoWzAtOWEtZl17OH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXsxMn0pXFx9JC9pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNsaWNlKDEsIDYpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgIGhleCA9XG4gICAgICAgICAgICAgICAgICAgIChfZCA9IC9edXJuOnV1aWQ6KFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KSQvaVxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zbGljZSgxLCA2KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIgKiBpLCAyICogaSArIDgpLCAxNik7XG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDBdID0gbiA+Pj4gMjQ7XG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDFdID0gbiA+Pj4gMTY7XG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDJdID0gbiA+Pj4gODtcbiAgICAgICAgICAgICAgICBpbm5lcltpICsgM10gPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKGlubmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcImNvdWxkIG5vdCBwYXJzZSBVVUlEIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogKGAwMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2JgKS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldID4+PiA0KTtcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldICYgMHhmKTtcbiAgICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBcIi1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIDMyLWRpZ2l0IGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgaHlwaGVuc1xuICAgICAqIChgMDE4OWRjZDU1MzExN2Q0MDhkYjA5NDk2YTJlZWYzN2JgKS5cbiAgICAgKi9cbiAgICB0b0hleCgpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldID4+PiA0KTtcbiAgICAgICAgICAgIHRleHQgKz0gRElHSVRTLmNoYXJBdCh0aGlzLmJ5dGVzW2ldICYgMHhmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqIEByZXR1cm5zIFRoZSA4LTQtNC00LTEyIGNhbm9uaWNhbCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIHRoZSB2YXJpYW50IGZpZWxkIHZhbHVlIG9mIHRoZSBVVUlEIG9yLCBpZiBhcHByb3ByaWF0ZSwgXCJOSUxcIiBvclxuICAgICAqIFwiTUFYXCIuXG4gICAgICpcbiAgICAgKiBGb3IgY29udmVuaWVuY2UsIHRoaXMgbWV0aG9kIHJlcG9ydHMgXCJOSUxcIiBvciBcIk1BWFwiIGlmIGB0aGlzYCByZXByZXNlbnRzXG4gICAgICogdGhlIE5pbCBvciBNYXggVVVJRCwgYWx0aG91Z2ggdGhlIE5pbCBhbmQgTWF4IFVVSURzIGFyZSB0ZWNobmljYWxseVxuICAgICAqIHN1YnN1bWVkIHVuZGVyIHRoZSB2YXJpYW50cyBgMGIwYCBhbmQgYDBiMTExYCwgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuICAgIGdldFZhcmlhbnQoKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmJ5dGVzWzhdID4+PiA0O1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIwMTExKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ldmVyeSgoZSkgPT4gZSA9PT0gMCkgPyBcIk5JTFwiIDogXCJWQVJfMFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIxMDExKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJWQVJfMTBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTEwMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVkFSXzExMFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPD0gMGIxMTExKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ldmVyeSgoZSkgPT4gZSA9PT0gMHhmZikgPyBcIk1BWFwiIDogXCJWQVJfUkVTRVJWRURcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gZmllbGQgdmFsdWUgb2YgdGhlIFVVSUQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIFVVSUQgZG9lc1xuICAgICAqIG5vdCBoYXZlIHRoZSB2YXJpYW50IGZpZWxkIHZhbHVlIG9mIGAwYjEwYC5cbiAgICAgKi9cbiAgICBnZXRWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50KCkgPT09IFwiVkFSXzEwXCIgPyB0aGlzLmJ5dGVzWzZdID4+PiA0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhbiBvYmplY3QgZnJvbSBgdGhpc2AuICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRCh0aGlzLmJ5dGVzLnNsaWNlKDApKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBgdGhpc2AgaXMgZXF1aXZhbGVudCB0byBgb3RoZXJgLiAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmVnYXRpdmUgaW50ZWdlciwgemVybywgb3IgcG9zaXRpdmUgaW50ZWdlciBpZiBgdGhpc2AgaXMgbGVzc1xuICAgICAqIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gYG90aGVyYCwgcmVzcGVjdGl2ZWx5LlxuICAgICAqL1xuICAgIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLmJ5dGVzW2ldIC0gb3RoZXIuYnl0ZXNbaV07XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNpZ24oZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuLyoqXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIG1vbm90b25pYyBjb3VudGVyIHN0YXRlLlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgQVBJcyB0byB1dGlsaXplIGEgc2VwYXJhdGUgY291bnRlciBzdGF0ZSBmcm9tIHRoYXQgb2YgdGhlXG4gKiBnbG9iYWwgZ2VuZXJhdG9yIHVzZWQgYnkge0BsaW5rIHV1aWR2N30gYW5kIHtAbGluayB1dWlkdjdvYmp9LiBJbiBhZGRpdGlvbiB0b1xuICogdGhlIGRlZmF1bHQge0BsaW5rIGdlbmVyYXRlfSBtZXRob2QsIHRoaXMgY2xhc3MgaGFzIHtAbGluayBnZW5lcmF0ZU9yQWJvcnR9XG4gKiB0aGF0IGlzIHVzZWZ1bCB0byBhYnNvbHV0ZWx5IGd1YXJhbnRlZSB0aGUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIG9yZGVyIG9mXG4gKiBnZW5lcmF0ZWQgVVVJRHMuIFNlZSB0aGVpciByZXNwZWN0aXZlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWN0dlbmVyYXRvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdlbmVyYXRvciBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCByYW5kb20gbnVtYmVyIGdlbmVyYXRvciwgb3JcbiAgICAgKiB3aXRoIHRoZSBzcGVjaWZpZWQgb25lIGlmIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gVGhlIHNwZWNpZmllZCByYW5kb21cbiAgICAgKiBudW1iZXIgZ2VuZXJhdG9yIHNob3VsZCBiZSBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgYW5kIHNlY3VyZWx5IHNlZWRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyYW5kb21OdW1iZXJHZW5lcmF0b3IpIHtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLnJhbmRvbSA9IHJhbmRvbU51bWJlckdlbmVyYXRvciAhPT0gbnVsbCAmJiByYW5kb21OdW1iZXJHZW5lcmF0b3IgIT09IHZvaWQgMCA/IHJhbmRvbU51bWJlckdlbmVyYXRvciA6IGdldERlZmF1bHRSYW5kb20oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NyBvYmplY3QgZnJvbSB0aGUgY3VycmVudCB0aW1lc3RhbXAsIG9yIHJlc2V0cyB0aGVcbiAgICAgKiBnZW5lcmF0b3IgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIFVVSUQgYnkgcmV1c2luZyB0aGUgcHJldmlvdXNcbiAgICAgKiB0aW1lc3RhbXAgZXZlbiBpZiB0aGUgdXAtdG8tZGF0ZSB0aW1lc3RhbXAgaXMgc21hbGxlciB0aGFuIHRoZSBpbW1lZGlhdGVseVxuICAgICAqIHByZWNlZGluZyBVVUlEJ3MuIEhvd2V2ZXIsIHdoZW4gc3VjaCBhIGNsb2NrIHJvbGxiYWNrIGlzIGNvbnNpZGVyZWRcbiAgICAgKiBzaWduaWZpY2FudCAoaS5lLiwgYnkgbW9yZSB0aGFuIHRlbiBzZWNvbmRzKSwgdGhpcyBtZXRob2QgcmVzZXRzIHRoZVxuICAgICAqIGdlbmVyYXRvciBhbmQgcmV0dXJucyBhIG5ldyBVVUlEIGJhc2VkIG9uIHRoZSBnaXZlbiB0aW1lc3RhbXAsIGJyZWFraW5nIHRoZVxuICAgICAqIGluY3JlYXNpbmcgb3JkZXIgb2YgVVVJRHMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGdlbmVyYXRlT3JBYm9ydH0gZm9yIHRoZSBvdGhlciBtb2RlIG9mIGdlbmVyYXRpb24gYW5kXG4gICAgICoge0BsaW5rIGdlbmVyYXRlT3JSZXNldENvcmV9IGZvciB0aGUgbG93LWxldmVsIHByaW1pdGl2ZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVPclJlc2V0Q29yZShEYXRlLm5vdygpLCAxMDAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBvciByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIFVVSUQgYnkgcmV1c2luZyB0aGUgcHJldmlvdXNcbiAgICAgKiB0aW1lc3RhbXAgZXZlbiBpZiB0aGUgdXAtdG8tZGF0ZSB0aW1lc3RhbXAgaXMgc21hbGxlciB0aGFuIHRoZSBpbW1lZGlhdGVseVxuICAgICAqIHByZWNlZGluZyBVVUlEJ3MuIEhvd2V2ZXIsIHdoZW4gc3VjaCBhIGNsb2NrIHJvbGxiYWNrIGlzIGNvbnNpZGVyZWRcbiAgICAgKiBzaWduaWZpY2FudCAoaS5lLiwgYnkgbW9yZSB0aGFuIHRlbiBzZWNvbmRzKSwgdGhpcyBtZXRob2QgYWJvcnRzIGFuZFxuICAgICAqIHJldHVybnMgYHVuZGVmaW5lZGAgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGdlbmVyYXRlfSBmb3IgdGhlIG90aGVyIG1vZGUgb2YgZ2VuZXJhdGlvbiBhbmRcbiAgICAgKiB7QGxpbmsgZ2VuZXJhdGVPckFib3J0Q29yZX0gZm9yIHRoZSBsb3ctbGV2ZWwgcHJpbWl0aXZlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlT3JBYm9ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVPckFib3J0Q29yZShEYXRlLm5vdygpLCAxMDAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGB1bml4VHNNc2AgcGFzc2VkLCBvciByZXNldHMgdGhlXG4gICAgICogZ2VuZXJhdG9yIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB7QGxpbmsgZ2VuZXJhdGV9IGV4Y2VwdCB0aGF0IGl0IHRha2VzIGEgY3VzdG9tXG4gICAgICogdGltZXN0YW1wIGFuZCBjbG9jayByb2xsYmFjayBhbGxvd2FuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9sbGJhY2tBbGxvd2FuY2UgLSBUaGUgYW1vdW50IG9mIGB1bml4VHNNc2Agcm9sbGJhY2sgdGhhdCBpc1xuICAgICAqIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuIEEgc3VnZ2VzdGVkIHZhbHVlIGlzIGAxMF8wMDBgIChtaWxsaXNlY29uZHMpLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBgdW5peFRzTXNgIGlzIG5vdCBhIDQ4LWJpdCBwb3NpdGl2ZSBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGdlbmVyYXRlT3JSZXNldENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2VuZXJhdGVPckFib3J0Q29yZSh1bml4VHNNcywgcm9sbGJhY2tBbGxvd2FuY2UpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmVzZXQgc3RhdGUgYW5kIHJlc3VtZVxuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSAwO1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGB1bml4VHNNc2AgcGFzc2VkLCBvciByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgdXBvbiBzaWduaWZpY2FudCB0aW1lc3RhbXAgcm9sbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIHtAbGluayBnZW5lcmF0ZU9yQWJvcnR9IGV4Y2VwdCB0aGF0IGl0IHRha2VzIGFcbiAgICAgKiBjdXN0b20gdGltZXN0YW1wIGFuZCBjbG9jayByb2xsYmFjayBhbGxvd2FuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9sbGJhY2tBbGxvd2FuY2UgLSBUaGUgYW1vdW50IG9mIGB1bml4VHNNc2Agcm9sbGJhY2sgdGhhdCBpc1xuICAgICAqIGNvbnNpZGVyZWQgc2lnbmlmaWNhbnQuIEEgc3VnZ2VzdGVkIHZhbHVlIGlzIGAxMF8wMDBgIChtaWxsaXNlY29uZHMpLlxuICAgICAqIEB0aHJvd3MgUmFuZ2VFcnJvciBpZiBgdW5peFRzTXNgIGlzIG5vdCBhIDQ4LWJpdCBwb3NpdGl2ZSBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKSB7XG4gICAgICAgIGNvbnN0IE1BWF9DT1VOVEVSID0gNDM5ODA0NjUxMTEwMztcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHVuaXhUc01zKSB8fFxuICAgICAgICAgICAgdW5peFRzTXMgPCAxIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA+IDI4MTQ3NDk3NjcxMDY1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJgdW5peFRzTXNgIG11c3QgYmUgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb2xsYmFja0FsbG93YW5jZSA8IDAgfHwgcm9sbGJhY2tBbGxvd2FuY2UgPiAyODE0NzQ5NzY3MTA2NTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYHJvbGxiYWNrQWxsb3dhbmNlYCBvdXQgb2YgcmVhc29uYWJsZSByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5peFRzTXMgPiB0aGlzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB1bml4VHNNcztcbiAgICAgICAgICAgIHRoaXMucmVzZXRDb3VudGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5peFRzTXMgKyByb2xsYmFja0FsbG93YW5jZSA+PSB0aGlzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgLy8gZ28gb24gd2l0aCBwcmV2aW91cyB0aW1lc3RhbXAgaWYgbmV3IG9uZSBpcyBub3QgbXVjaCBzbWFsbGVyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPiBNQVhfQ09VTlRFUikge1xuICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aW1lc3RhbXAgYXQgY291bnRlciBvdmVyZmxvd1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wKys7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENvdW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFib3J0IGlmIGNsb2NrIHdlbnQgYmFja3dhcmRzIHRvIHVuYmVhcmFibGUgZXh0ZW50XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVVUlELmZyb21GaWVsZHNWNyh0aGlzLnRpbWVzdGFtcCwgTWF0aC50cnVuYyh0aGlzLmNvdW50ZXIgLyAyICoqIDMwKSwgdGhpcy5jb3VudGVyICYgKDIgKiogMzAgLSAxKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpKTtcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemVzIHRoZSBjb3VudGVyIGF0IGEgNDItYml0IHJhbmRvbSBpbnRlZ2VyLiAqL1xuICAgIHJlc2V0Q291bnRlcigpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyID1cbiAgICAgICAgICAgIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSAqIDB4NDAwICsgKHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSAmIDB4M2ZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IFVVSUR2NCBvYmplY3QgdXRpbGl6aW5nIHRoZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpbnNpZGUuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVY0KCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KFVpbnQzMkFycmF5Lm9mKHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSkuYnVmZmVyKTtcbiAgICAgICAgYnl0ZXNbNl0gPSAweDQwIHwgKGJ5dGVzWzZdID4+PiA0KTtcbiAgICAgICAgYnl0ZXNbOF0gPSAweDgwIHwgKGJ5dGVzWzhdID4+PiAyKTtcbiAgICAgICAgcmV0dXJuIFVVSUQub2ZJbm5lcihieXRlcyk7XG4gICAgfVxufVxuLyoqIFJldHVybnMgdGhlIGRlZmF1bHQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgYXZhaWxhYmxlIGluIHRoZSBlbnZpcm9ubWVudC4gKi9cbmNvbnN0IGdldERlZmF1bHRSYW5kb20gPSAoKSA9PiB7XG4gICAgLy8gZGV0ZWN0IFdlYiBDcnlwdG8gQVBJXG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJlZENyeXB0b1JhbmRvbSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIG9uIE1hdGgucmFuZG9tKCkgdW5sZXNzIHRoZSBmbGFnIGlzIHNldCB0byB0cnVlXG4gICAgICAgIGlmICh0eXBlb2YgVVVJRFY3X0RFTllfV0VBS19STkcgIT09IFwidW5kZWZpbmVkXCIgJiYgVVVJRFY3X0RFTllfV0VBS19STkcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBSTkcgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0VWludDMyOiAoKSA9PiBNYXRoLnRydW5jKE1hdGgucmFuZG9tKCkgKiA2NTUzNikgKiA2NTUzNiArXG4gICAgICAgICAgICAgICAgTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogNjU1MzYpLFxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFdyYXBzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKClgIHRvIGVuYWJsZSBidWZmZXJpbmc7IHRoaXMgdXNlcyBhIHNtYWxsXG4gKiBidWZmZXIgYnkgZGVmYXVsdCB0byBhdm9pZCBib3RoIHVuYmVhcmFibGUgdGhyb3VnaHB1dCBkZWNsaW5lIGluIHNvbWVcbiAqIGVudmlyb25tZW50cyBhbmQgdGhlIHdhc3RlIG9mIHRpbWUgYW5kIHNwYWNlIGZvciB1bnVzZWQgdmFsdWVzLlxuICovXG5jbGFzcyBCdWZmZXJlZENyeXB0b1JhbmRvbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KDgpO1xuICAgICAgICB0aGlzLmN1cnNvciA9IDB4ZmZmZjtcbiAgICB9XG4gICAgbmV4dFVpbnQzMigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yID49IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuY3Vyc29yKytdO1xuICAgIH1cbn1cbmxldCBkZWZhdWx0R2VuZXJhdG9yO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBVVUlEdjcgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIFRoZSA4LTQtNC00LTEyIGNhbm9uaWNhbCBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIChcInh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFwiKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHV1aWR2NyA9ICgpID0+IHV1aWR2N29iaigpLnRvU3RyaW5nKCk7XG4vKiogR2VuZXJhdGVzIGEgVVVJRHY3IG9iamVjdC4gKi9cbmV4cG9ydCBjb25zdCB1dWlkdjdvYmogPSAoKSA9PiAoZGVmYXVsdEdlbmVyYXRvciB8fCAoZGVmYXVsdEdlbmVyYXRvciA9IG5ldyBWN0dlbmVyYXRvcigpKSkuZ2VuZXJhdGUoKTtcbi8qKlxuICogR2VuZXJhdGVzIGEgVVVJRHY0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIikuXG4gKi9cbmV4cG9ydCBjb25zdCB1dWlkdjQgPSAoKSA9PiB1dWlkdjRvYmooKS50b1N0cmluZygpO1xuLyoqIEdlbmVyYXRlcyBhIFVVSUR2NCBvYmplY3QuICovXG5leHBvcnQgY29uc3QgdXVpZHY0b2JqID0gKCkgPT4gKGRlZmF1bHRHZW5lcmF0b3IgfHwgKGRlZmF1bHRHZW5lcmF0b3IgPSBuZXcgVjdHZW5lcmF0b3IoKSkpLmdlbmVyYXRlVjQoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/uuidv7/dist/index.js\n");

/***/ })

};
;